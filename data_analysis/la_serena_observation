import csv
from skyfield.api import EarthSatellite, load, wgs84, Star
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from tqdm import tqdm
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import winsound
from skyfield.iokit import parse_tle_file #parse as tle instead of csv for continuity with sopp
from skyfield.api import Angle

antenna_alt = 0.0
antenna_az = 240.0

#satellite class for plotting flight path easier
class Satellite:
    def __init__(self, name):
        self.name = name
        self.times = []  #list of datetime objects
        self.alts = []  
        self.azs = []  

    def add_position(self, time, alt, az):
        self.times.append(time)
        self.alts.append(alt)
        self.azs.append(az)

#load earth data from skyfield, timescale, beamwidth 
planets = load('de421.bsp')
earth = planets['earth']
ts = load.timescale()

beamwidth = 30

#ensure variables can be imported (for later gui implementation)
__all__ = [
    "sat_track_plot", "select_data", "precompute_target_positions", 
    "precompute_satellite_positions", "check_satellite_intersect", "earth", "ts"
]

def select_data(type):
    max_days = 7.0         #download again once 7 days old
    name = f'{type}.tle'   #custom filename based on type
    
    base = 'https://celestrak.org/NORAD/elements/gp.php'
    url = f'{base}?GROUP={type}&FORMAT=tle'  #dynamically insert type
    
    if not load.exists(name) or load.days_old(name) >= max_days:
        load.download(url, filename=name)
    
    with load.open(name) as f:
        sats = list(parse_tle_file(f, ts))#changed from csv for continuity with SOPP
    print('Loaded', len(sats), 'satellites')
    return sats

    #load satellite data
sats = select_data("active")

def precompute_satellite_positions(sats, time_steps, observer):
    return {sat: (sat - observer).at(time_steps) for sat in sats}

def check_satellite_intersect(t_index, targPos, sat_positions):
    intersecting_sats = []
    
    #loop through sat positions at a certain time and check if it's near target
    for sat, topocentric in sat_positions.items():
        difference_angle = targPos.separation_from(topocentric[t_index])
        

        if difference_angle.degrees < beamwidth: #adjusted to match the rayleigh criterion, 2 sigma
            intersecting_sats.append((sat, topocentric[t_index], difference_angle))
    
    return intersecting_sats

def sat_track_plot(observer, t_init, t_end, sats):
    #Lists for plotting
    times = []
    sat_times, sat_alts, sat_azs = [], [], []

    #List for CSV export
    output_data = []

    one_second = np.float64(0.00001157407) #skyfield time maths sets 1 day = 1
    time_steps = ts.tt_jd(np.arange(t_init.tt, t_end.tt, one_second))  #vectorised time steps to save compute time
    total_steps = len(time_steps)


    #determine positions before checking angle difference - faster
    alt = Angle(degrees = antenna_alt)
    az = Angle(degrees = antenna_az)
    precomputed_sat_positions = precompute_satellite_positions(sats, time_steps, observer)
    
    satellites = [] #initialise a list of satellite objects

    with tqdm(total=total_steps, desc="Processing", unit="step") as pbar:#creates a progress bar - observations can be long
        for i, t_temp in enumerate(time_steps): 
            position = observer.at(t_temp).from_altaz(alt=alt, az=az)
            #store target position for plotting
            times.append(t_temp.utc_datetime())
            
            #add target data for CSV output
            output_data.append([t_temp.utc_strftime(), "Target", alt.degrees, az.degrees, "-"])
            
            #check for satellite intersections
            sat_intersects = check_satellite_intersect(i, position, precomputed_sat_positions)
            for sat, topocentric, difference_angle in sat_intersects:
                sat_alt, sat_az, _ = topocentric.altaz()

                #add satellite data to the relevant satellite object
                sat_obj = next((s for s in satellites if s.name == sat.name), None)
                if sat_obj is None:
                    sat_obj = Satellite(name=sat.name)
                    satellites.append(sat_obj)
                
                sat_obj.add_position(t_temp.utc_datetime(), sat_alt.degrees, sat_az.degrees)

                #add satellite data for CSV output
                output_data.append([
                    t_temp.utc_strftime(),
                    sat.name,
                    sat_alt.degrees,
                    sat_az.degrees,
                    difference_angle.degrees
                ])
            pbar.update(1)  #update progress bar         

    #save data to CSV file
    local_time = datetime.now()
    timestamp = local_time.strftime("%Y-%m-%d_%H-%M-%S")
    filename = f"sat_intersect_{timestamp}.csv"

    with open(filename, mode='w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["Time", "Object", "Altitude", "Azimuth", "Angular Separation"])
        writer.writerows(output_data)

    print(f"Saved satellite and target position data to {filename}")
    winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)

    #plot
    alts = np.full(len(time_steps), antenna_alt)
    azs  = np.full(len(time_steps), antenna_az)
    fig2d, anim = create_visualisation(times, alts, azs, satellites)
    plt.show()
    
def create_visualisation(times, alts, azs, satellites):
    
    #animated plot
    #use dictionary to organise data by time
    time_organised_data = {}
    for i, t in enumerate(times):
        time_key = t.strftime("%Y-%m-%d %H:%M:%S")
        if time_key not in time_organised_data:
            time_organised_data[time_key] = []
        time_organised_data[time_key].append({
            'name': 'Target',
            'alt': alts[i],
            'az': azs[i]
        })
    
    #sdd satellite data
    for sat in satellites:
        for i, t in enumerate(sat.times):
            time_key = t.strftime("%Y-%m-%d %H:%M:%S")
            if time_key not in time_organised_data:
                time_organised_data[time_key] = []
            time_organised_data[time_key].append({
                'name': sat.name,
                'alt': sat.alts[i],
                'az': sat.azs[i]
            })
    
    #sort times
    sorted_times = list(sorted(time_organised_data.keys()))
    
    #initialise plot
    fig2 = plt.figure(figsize=(8, 8))
    ax2 = fig2.add_subplot(111, projection='polar')

    # Configure orientation
    ax2.set_theta_zero_location('N')   # 0° at North
    ax2.set_theta_direction(-1)        # Clockwise azimuth

    # Radius setup (0 = zenith, 90 = horizon)
    ax2.set_rlim(0, 90)
    ax2.set_rlabel_position(135)
    
    #for zenith observations
    theta = np.linspace(0, 2*np.pi, 360)
    r_beam = np.full_like(theta, beamwidth)
    ax2.fill(theta, r_beam, alpha=0.15)


    target_point, = ax2.plot([], [], 'bo', markersize=6)
    target_traj, = ax2.plot([], [], 'b-', alpha=0.3)

    sat_markers = []

    def init():
        target_point.set_data([], [])
        target_traj.set_data([], [])
        return [target_point, target_traj]

    def animate(i):
        tkey = sorted_times[i]

        # Clear old satellites
        for m in sat_markers[:]:
            m.remove()
            sat_markers.remove(m)

        objs = time_organised_data[tkey]

        traj_theta = []
        traj_r = []

        for obj in objs:
            theta = np.deg2rad(obj['az'])
            r = 90 - obj['alt']

            if obj['name'] == 'Target':
                target_point.set_data([theta], [r])
                traj_theta.append(theta)
                traj_r.append(r)
            else:
                m, = ax2.plot(theta, r, 'rx', markersize=8)
                sat_markers.append(m)

        if traj_theta:
            target_traj.set_data(traj_theta, traj_r)

        ax2.set_title(f"Sky View — {tkey} UTC")

        return [target_point, target_traj] + sat_markers
    
    #display
    animation = FuncAnimation(
        fig2, animate, init_func=init, frames=len(sorted_times), interval=10, blit=False
    )
    
    return fig2, animation

def get_observation_data(): #hard-coded for some data analysis
    year, month, day, hour, minute, duration = 2026, 1, 21, 13, 8, 0.5 #time UTC
    observer = wgs84.latlon(-29.61933, -70.7705829, elevation_m=2000)  #location
    print("29deg 37' 9\" south, 70deg 46' 12\" west, 2000m elevation")
    return year, month, day, hour, minute, duration, observer

def main():
    #get user inputs
    year, month, day, hour, minute, duration, observer = get_observation_data()

    #define time range
    start_time = ts.utc(year, month, day, hour, minute)
    end_time = ts.utc(year, month, day, hour, minute + duration) 
    
    #run interference checker/plotter
    sat_track_plot(observer, start_time, end_time, sats)

if __name__ == "__main__":
    main()
